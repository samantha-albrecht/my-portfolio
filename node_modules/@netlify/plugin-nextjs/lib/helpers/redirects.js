"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateRedirects = exports.generateStaticRedirects = void 0;
const fs_extra_1 = require("fs-extra");
const pathe_1 = require("pathe");
const constants_1 = require("../constants");
const utils_1 = require("./utils");
const generateLocaleRedirects = ({ i18n, basePath, trailingSlash, }) => {
    const redirects = [];
    // If the cookie is set, we need to redirect at the origin
    redirects.push({
        from: `${basePath}/`,
        to: constants_1.HANDLER_FUNCTION_PATH,
        status: 200,
        force: true,
        conditions: {
            Cookie: ['NEXT_LOCALE'],
        },
    });
    i18n.locales.forEach((locale) => {
        if (locale === i18n.defaultLocale) {
            return;
        }
        redirects.push({
            from: `${basePath}/`,
            to: `${basePath}/${locale}${trailingSlash ? '/' : ''}`,
            status: 301,
            conditions: {
                Language: [locale],
            },
            force: true,
        });
    });
    return redirects;
};
const generateStaticRedirects = ({ netlifyConfig, nextConfig: { i18n, basePath }, }) => {
    // Static files are in `static`
    netlifyConfig.redirects.push({ from: `${basePath}/_next/static/*`, to: `/static/:splat`, status: 200 });
    if (i18n) {
        netlifyConfig.redirects.push({ from: `${basePath}/:locale/_next/static/*`, to: `/static/:splat`, status: 200 });
    }
};
exports.generateStaticRedirects = generateStaticRedirects;
const generateRedirects = async ({ netlifyConfig, nextConfig: { i18n, basePath, trailingSlash, appDir }, buildId, }) => {
    const { dynamicRoutes: prerenderedDynamicRoutes, routes: prerenderedStaticRoutes } = await fs_extra_1.readJSON(pathe_1.join(netlifyConfig.build.publish, 'prerender-manifest.json'));
    const { dynamicRoutes, staticRoutes } = await fs_extra_1.readJSON(pathe_1.join(netlifyConfig.build.publish, 'routes-manifest.json'));
    netlifyConfig.redirects.push(...constants_1.HIDDEN_PATHS.map((path) => ({
        from: `${basePath}${path}`,
        to: '/404.html',
        status: 404,
        force: true,
    })));
    if (i18n && i18n.localeDetection !== false) {
        netlifyConfig.redirects.push(...generateLocaleRedirects({ i18n, basePath, trailingSlash }));
    }
    // This is only used in prod, so dev uses `next dev` directly
    netlifyConfig.redirects.push(
    // API routes always need to be served from the regular function
    ...utils_1.getApiRewrites(basePath), 
    // Preview mode gets forced to the function, to bypass pre-rendered pages, but static files need to be skipped
    ...(await utils_1.getPreviewRewrites({ basePath, appDir })));
    const staticRouteEntries = Object.entries(prerenderedStaticRoutes);
    const staticRoutePaths = new Set();
    // First add all static ISR routes
    staticRouteEntries.forEach(([route, { initialRevalidateSeconds }]) => {
        if (utils_1.isApiRoute(route)) {
            return;
        }
        staticRoutePaths.add(route);
        if (initialRevalidateSeconds === false) {
            // These can be ignored, as they're static files handled by the CDN
            return;
        }
        // The default locale is served from the root, not the localised path
        if ((i18n === null || i18n === void 0 ? void 0 : i18n.defaultLocale) && route.startsWith(`/${i18n.defaultLocale}/`)) {
            route = route.slice(i18n.defaultLocale.length + 1);
            staticRoutePaths.add(route);
            netlifyConfig.redirects.push(...utils_1.redirectsForNextRouteWithData({
                route,
                dataRoute: utils_1.routeToDataRoute(route, buildId, i18n.defaultLocale),
                basePath,
                to: constants_1.ODB_FUNCTION_PATH,
                force: true,
            }));
        }
        else {
            // ISR routes use the ODB handler
            netlifyConfig.redirects.push(
            // No i18n, because the route is already localized
            ...utils_1.redirectsForNextRoute({ route, basePath, to: constants_1.ODB_FUNCTION_PATH, force: true, buildId, i18n: null }));
        }
    });
    // Add rewrites for all static SSR routes. This is Next 12+
    staticRoutes === null || staticRoutes === void 0 ? void 0 : staticRoutes.forEach((route) => {
        if (staticRoutePaths.has(route.page) || utils_1.isApiRoute(route.page)) {
            // Prerendered static routes are either handled by the CDN or are ISR
            return;
        }
        netlifyConfig.redirects.push(...utils_1.redirectsForNextRoute({ route: route.page, buildId, basePath, to: constants_1.HANDLER_FUNCTION_PATH, i18n }));
    });
    // Add rewrites for all dynamic routes (both SSR and ISR)
    dynamicRoutes.forEach((route) => {
        if (utils_1.isApiRoute(route.page)) {
            return;
        }
        if (route.page in prerenderedDynamicRoutes) {
            const { fallback } = prerenderedDynamicRoutes[route.page];
            const { to, status } = utils_1.targetForFallback(fallback);
            netlifyConfig.redirects.push(...utils_1.redirectsForNextRoute({ buildId, route: route.page, basePath, to, status, i18n }));
        }
        else {
            // If the route isn't prerendered, it's SSR
            netlifyConfig.redirects.push(...utils_1.redirectsForNextRoute({ route: route.page, buildId, basePath, to: constants_1.HANDLER_FUNCTION_PATH, i18n }));
        }
    });
    // Final fallback
    netlifyConfig.redirects.push({
        from: `${basePath}/*`,
        to: constants_1.HANDLER_FUNCTION_PATH,
        status: 200,
    });
};
exports.generateRedirects = generateRedirects;
